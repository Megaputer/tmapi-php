<?php
/**
 * TokensResponseTokens
 *
 * PHP version 5
 *
 * @category Class
 * @package  TmApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Megaputer Text Mining API
 *
 * Megaputer Text Mining API
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.3.4-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace TmApi\Model;

use \ArrayAccess;
use \TmApi\ObjectSerializer;

/**
 * TokensResponseTokens Class Doc Comment
 *
 * @category Class
 * @package  TmApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TokensResponseTokens implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'TokensResponse_tokens';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'word' => 'string',
        'lemma' => 'string',
        'part_of_speech' => 'string',
        'modifier' => 'object',
        'is_extension' => 'int',
        'position' => '\TmApi\Model\TokensResponsePosition'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'word' => null,
        'lemma' => null,
        'part_of_speech' => null,
        'modifier' => null,
        'is_extension' => 'int32',
        'position' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'word' => 'word',
        'lemma' => 'lemma',
        'part_of_speech' => 'partOfSpeech',
        'modifier' => 'modifier',
        'is_extension' => 'isExtension',
        'position' => 'position'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'word' => 'setWord',
        'lemma' => 'setLemma',
        'part_of_speech' => 'setPartOfSpeech',
        'modifier' => 'setModifier',
        'is_extension' => 'setIsExtension',
        'position' => 'setPosition'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'word' => 'getWord',
        'lemma' => 'getLemma',
        'part_of_speech' => 'getPartOfSpeech',
        'modifier' => 'getModifier',
        'is_extension' => 'getIsExtension',
        'position' => 'getPosition'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const PART_OF_SPEECH_NOUN = 'Noun';
    const PART_OF_SPEECH_VERB = 'Verb';
    const PART_OF_SPEECH_ADVERB = 'Adverb';
    const PART_OF_SPEECH_ADJECTIVE = 'Adjective';
    const PART_OF_SPEECH_PARTICLE = 'Particle';
    const PART_OF_SPEECH_PRONOUN = 'Pronoun';
    const PART_OF_SPEECH_NUMERAL = 'Numeral';
    const PART_OF_SPEECH_SPECIAL = 'Special';
    const PART_OF_SPEECH_PUNCTUATION = 'Punctuation';
    const IS_EXTENSION_0 = 0;
    const IS_EXTENSION_1 = 1;
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPartOfSpeechAllowableValues()
    {
        return [
            self::PART_OF_SPEECH_NOUN,
            self::PART_OF_SPEECH_VERB,
            self::PART_OF_SPEECH_ADVERB,
            self::PART_OF_SPEECH_ADJECTIVE,
            self::PART_OF_SPEECH_PARTICLE,
            self::PART_OF_SPEECH_PRONOUN,
            self::PART_OF_SPEECH_NUMERAL,
            self::PART_OF_SPEECH_SPECIAL,
            self::PART_OF_SPEECH_PUNCTUATION,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getIsExtensionAllowableValues()
    {
        return [
            self::IS_EXTENSION_0,
            self::IS_EXTENSION_1,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['word'] = isset($data['word']) ? $data['word'] : null;
        $this->container['lemma'] = isset($data['lemma']) ? $data['lemma'] : null;
        $this->container['part_of_speech'] = isset($data['part_of_speech']) ? $data['part_of_speech'] : null;
        $this->container['modifier'] = isset($data['modifier']) ? $data['modifier'] : null;
        $this->container['is_extension'] = isset($data['is_extension']) ? $data['is_extension'] : null;
        $this->container['position'] = isset($data['position']) ? $data['position'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getPartOfSpeechAllowableValues();
        if (!is_null($this->container['part_of_speech']) && !in_array($this->container['part_of_speech'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'part_of_speech', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getIsExtensionAllowableValues();
        if (!is_null($this->container['is_extension']) && !in_array($this->container['is_extension'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'is_extension', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets word
     *
     * @return string|null
     */
    public function getWord()
    {
        return $this->container['word'];
    }

    /**
     * Sets word
     *
     * @param string|null $word Word as in text
     *
     * @return $this
     */
    public function setWord($word)
    {
        $this->container['word'] = $word;

        return $this;
    }

    /**
     * Gets lemma
     *
     * @return string|null
     */
    public function getLemma()
    {
        return $this->container['lemma'];
    }

    /**
     * Sets lemma
     *
     * @param string|null $lemma A dictionary form of a word, e.g. given verb forms \"run\", \"ran\" and \"runs\", \"run\" is the lemma
     *
     * @return $this
     */
    public function setLemma($lemma)
    {
        $this->container['lemma'] = $lemma;

        return $this;
    }

    /**
     * Gets part_of_speech
     *
     * @return string|null
     */
    public function getPartOfSpeech()
    {
        return $this->container['part_of_speech'];
    }

    /**
     * Sets part_of_speech
     *
     * @param string|null $part_of_speech Assigns a word to a morphological category according to each syntactic functions.
     *
     * @return $this
     */
    public function setPartOfSpeech($part_of_speech)
    {
        $allowedValues = $this->getPartOfSpeechAllowableValues();
        if (!is_null($part_of_speech) && !in_array($part_of_speech, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'part_of_speech', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['part_of_speech'] = $part_of_speech;

        return $this;
    }

    /**
     * Gets modifier
     *
     * @return object|null
     */
    public function getModifier()
    {
        return $this->container['modifier'];
    }

    /**
     * Sets modifier
     *
     * @param object|null $modifier One of the grammatical categories of a word, e.g. person for verbs or number for nouns. Each part of speech has its own set of modifiers.  The detailed list of parameters can be found in Help to TM API Server.
     *
     * @return $this
     */
    public function setModifier($modifier)
    {
        $this->container['modifier'] = $modifier;

        return $this;
    }

    /**
     * Gets is_extension
     *
     * @return int|null
     */
    public function getIsExtension()
    {
        return $this->container['is_extension'];
    }

    /**
     * Sets is_extension
     *
     * @param int|null $is_extension Indicates a way of writing a token with the previous one. It returns \"1\", if tokens are written as a single token. It returns \"0\", if tokens are written separately.
     *
     * @return $this
     */
    public function setIsExtension($is_extension)
    {
        $allowedValues = $this->getIsExtensionAllowableValues();
        if (!is_null($is_extension) && !in_array($is_extension, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'is_extension', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['is_extension'] = $is_extension;

        return $this;
    }

    /**
     * Gets position
     *
     * @return \TmApi\Model\TokensResponsePosition|null
     */
    public function getPosition()
    {
        return $this->container['position'];
    }

    /**
     * Sets position
     *
     * @param \TmApi\Model\TokensResponsePosition|null $position position
     *
     * @return $this
     */
    public function setPosition($position)
    {
        $this->container['position'] = $position;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }
}


