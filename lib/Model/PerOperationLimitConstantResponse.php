<?php
/**
 * PerOperationLimitConstantResponse
 *
 * PHP version 5
 *
 * @category Class
 * @package  TmApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Megaputer Text Mining API
 *
 * Megaputer Text Mining API
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.3.4-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace TmApi\Model;

use \ArrayAccess;
use \TmApi\ObjectSerializer;

/**
 * PerOperationLimitConstantResponse Class Doc Comment
 *
 * @category Class
 * @package  TmApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PerOperationLimitConstantResponse implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'PerOperationLimitConstantResponse';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'ntu_limit' => 'int',
        'ntu_tokens' => 'int',
        'ntu_keywords' => 'int',
        'ntu_entities' => 'int',
        'ntu_languages' => 'int',
        'ntu_sentiments' => 'int',
        'ntu_facts' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'ntu_limit' => 'int32',
        'ntu_tokens' => 'int32',
        'ntu_keywords' => 'int32',
        'ntu_entities' => 'int32',
        'ntu_languages' => 'int32',
        'ntu_sentiments' => 'int32',
        'ntu_facts' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'ntu_limit' => 'NTULimit',
        'ntu_tokens' => 'NTUTokens',
        'ntu_keywords' => 'NTUKeywords',
        'ntu_entities' => 'NTUEntities',
        'ntu_languages' => 'NTULanguages',
        'ntu_sentiments' => 'NTUSentiments',
        'ntu_facts' => 'NTUFacts'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'ntu_limit' => 'setNtuLimit',
        'ntu_tokens' => 'setNtuTokens',
        'ntu_keywords' => 'setNtuKeywords',
        'ntu_entities' => 'setNtuEntities',
        'ntu_languages' => 'setNtuLanguages',
        'ntu_sentiments' => 'setNtuSentiments',
        'ntu_facts' => 'setNtuFacts'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'ntu_limit' => 'getNtuLimit',
        'ntu_tokens' => 'getNtuTokens',
        'ntu_keywords' => 'getNtuKeywords',
        'ntu_entities' => 'getNtuEntities',
        'ntu_languages' => 'getNtuLanguages',
        'ntu_sentiments' => 'getNtuSentiments',
        'ntu_facts' => 'getNtuFacts'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['ntu_limit'] = isset($data['ntu_limit']) ? $data['ntu_limit'] : null;
        $this->container['ntu_tokens'] = isset($data['ntu_tokens']) ? $data['ntu_tokens'] : null;
        $this->container['ntu_keywords'] = isset($data['ntu_keywords']) ? $data['ntu_keywords'] : null;
        $this->container['ntu_entities'] = isset($data['ntu_entities']) ? $data['ntu_entities'] : null;
        $this->container['ntu_languages'] = isset($data['ntu_languages']) ? $data['ntu_languages'] : null;
        $this->container['ntu_sentiments'] = isset($data['ntu_sentiments']) ? $data['ntu_sentiments'] : null;
        $this->container['ntu_facts'] = isset($data['ntu_facts']) ? $data['ntu_facts'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets ntu_limit
     *
     * @return int|null
     */
    public function getNtuLimit()
    {
        return $this->container['ntu_limit'];
    }

    /**
     * Sets ntu_limit
     *
     * @param int|null $ntu_limit The maximum number of text units that can be processed in all time
     *
     * @return $this
     */
    public function setNtuLimit($ntu_limit)
    {
        $this->container['ntu_limit'] = $ntu_limit;

        return $this;
    }

    /**
     * Gets ntu_tokens
     *
     * @return int|null
     */
    public function getNtuTokens()
    {
        return $this->container['ntu_tokens'];
    }

    /**
     * Sets ntu_tokens
     *
     * @param int|null $ntu_tokens Counter of text units that have been already processed for operation Text parsing
     *
     * @return $this
     */
    public function setNtuTokens($ntu_tokens)
    {
        $this->container['ntu_tokens'] = $ntu_tokens;

        return $this;
    }

    /**
     * Gets ntu_keywords
     *
     * @return int|null
     */
    public function getNtuKeywords()
    {
        return $this->container['ntu_keywords'];
    }

    /**
     * Sets ntu_keywords
     *
     * @param int|null $ntu_keywords Counter of text units that have been already processed for operation Keywords extraction
     *
     * @return $this
     */
    public function setNtuKeywords($ntu_keywords)
    {
        $this->container['ntu_keywords'] = $ntu_keywords;

        return $this;
    }

    /**
     * Gets ntu_entities
     *
     * @return int|null
     */
    public function getNtuEntities()
    {
        return $this->container['ntu_entities'];
    }

    /**
     * Sets ntu_entities
     *
     * @param int|null $ntu_entities Counter of text units that have been already processed for operation Entities extraction
     *
     * @return $this
     */
    public function setNtuEntities($ntu_entities)
    {
        $this->container['ntu_entities'] = $ntu_entities;

        return $this;
    }

    /**
     * Gets ntu_languages
     *
     * @return int|null
     */
    public function getNtuLanguages()
    {
        return $this->container['ntu_languages'];
    }

    /**
     * Sets ntu_languages
     *
     * @param int|null $ntu_languages Counter of text units that have been already processed for operation Language detection
     *
     * @return $this
     */
    public function setNtuLanguages($ntu_languages)
    {
        $this->container['ntu_languages'] = $ntu_languages;

        return $this;
    }

    /**
     * Gets ntu_sentiments
     *
     * @return int|null
     */
    public function getNtuSentiments()
    {
        return $this->container['ntu_sentiments'];
    }

    /**
     * Sets ntu_sentiments
     *
     * @param int|null $ntu_sentiments Counter of text units that have been already processed for operation Sentiments analysis
     *
     * @return $this
     */
    public function setNtuSentiments($ntu_sentiments)
    {
        $this->container['ntu_sentiments'] = $ntu_sentiments;

        return $this;
    }

    /**
     * Gets ntu_facts
     *
     * @return int|null
     */
    public function getNtuFacts()
    {
        return $this->container['ntu_facts'];
    }

    /**
     * Sets ntu_facts
     *
     * @param int|null $ntu_facts Counter of text units that have been already processed for operation Facts extraction
     *
     * @return $this
     */
    public function setNtuFacts($ntu_facts)
    {
        $this->container['ntu_facts'] = $ntu_facts;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }
}


